<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Эволюция - Плавная версия</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        body { 
            background: radial-gradient(ellipse at bottom, #1B2735 0%, #090A0F 100%);
            touch-action: none; 
            overflow: hidden; 
            font-family: 'Inter', sans-serif;
            -webkit-tap-highlight-color: transparent;
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 0 20px rgba(0,0,0,0.2);
        }

        /* --- НОВЫЙ ДВИЖОК СЕТКИ --- */
        .board-container {
            --grid-gap: 0.5rem; /* 8px отступы */
            --cell-size: calc((100% - var(--grid-gap) * 3) / 4);
            position: relative;
            padding: var(--grid-gap);
        }

        .tile-animated {
            position: absolute;
            width: var(--cell-size);
            height: var(--cell-size);
            /* Плавное перемещение на основе CSS-переменных координат */
            transform: translate(
                calc(var(--c) * (var(--cell-size) + var(--grid-gap))), 
                calc(var(--r) * (var(--cell-size) + var(--grid-gap)))
            );
            transition: transform 0.15s ease-in-out;
            top: var(--grid-gap);
            left: var(--grid-gap);
        }

        .tile-base {
            width: 100%; height: 100%;
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }

        /* --- АНИМАЦИИ --- */
        .tile-new-appear { animation: appear-smooth 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        @keyframes appear-smooth {
            0% { opacity: 0; transform: scale(0.3); }
            100% { opacity: 1; transform: scale(1); }
        }

        .tile-merged-pop { animation: pop-intense 0.25s cubic-bezier(0.34, 1.56, 0.64, 1) forwards; }
        @keyframes pop-intense {
            0% { transform: scale(1); }
            50% { transform: scale(1.15); filter: brightness(1.5); }
            100% { transform: scale(1); }
        }

        @keyframes particle-burst {
            0% { transform: translate(0, 0) scale(1.5); opacity: 1; filter: blur(0px); }
            100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; filter: blur(2px); }
        }
        .particle {
            position: absolute;
            width: 6px; height: 6px;
            border-radius: 50%;
            background: white;
            box-shadow: 0 0 8px white;
            animation: particle-burst 0.5s cubic-bezier(0.25, 1, 0.5, 1) forwards;
            pointer-events: none;
            z-index: 30;
        }

        .score-anim { animation: score-float 0.8s ease-out forwards; position: absolute; font-weight: 900; color: #4ade80; text-shadow: 0 0 10px #4ade80; pointer-events: none; z-index: 50; }
        @keyframes score-float {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-30px) scale(1.2); }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
</head>
<body class="text-white flex items-center justify-center min-h-screen antialiased">
    <div id="root" class="w-full h-full flex items-center justify-center p-4"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;

        const TILE_DATA = {
            2: { icon: 'anvil', level: 1, color: 'text-stone-300', glow: '0 0 10px rgba(120, 113, 108, 0.5)' },
            4: { icon: 'tent', level: 2, color: 'text-orange-300', glow: '0 0 12px rgba(251, 146, 60, 0.6)' },
            8: { icon: 'sword', level: 3, color: 'text-red-300', glow: '0 0 15px rgba(248, 113, 113, 0.7)' },
            16: { icon: 'castle', level: 4, color: 'text-amber-300', glow: '0 0 15px rgba(251, 191, 36, 0.7)' },
            32: { icon: 'palette', level: 5, color: 'text-yellow-300', glow: '0 0 18px rgba(250, 204, 21, 0.8)' },
            64: { icon: 'factory', level: 6, color: 'text-lime-400', glow: '0 0 20px rgba(163, 230, 53, 0.8)' },
            128: { icon: 'satellite', level: 7, color: 'text-emerald-400', glow: '0 0 22px rgba(52, 211, 153, 0.9)' },
            256: { icon: 'cpu', level: 8, color: 'text-cyan-400', glow: '0 0 25px rgba(34, 211, 238, 0.9)' },
            512: { icon: 'bot', level: 9, color: 'text-blue-400', glow: '0 0 28px rgba(96, 165, 250, 1)' },
            1024: { icon: 'orbit', level: 10, color: 'text-violet-400', glow: '0 0 30px rgba(167, 139, 250, 1)' },
            2048: { icon: 'zap', level: 11, color: 'text-fuchsia-400', glow: '0 0 35px rgba(232, 121, 249, 1)' }
        };

        const App = () => {
            const tileIdCounter = useRef(1);
            const isMoving = useRef(false);

            // Состояние вынесено в один объект для избежания рассинхрона
            const [gameState, setGameState] = useState({
                tiles: [],
                score: 0,
                gameOver: false
            });
            const [highScore, setHighScore] = useState(() => Number(localStorage.getItem('evoHighScore')) || 0);
            const [scoreAdds, setScoreAdds] = useState([]);
            const audioCtx = useRef(null);
            const touchStart = useRef({ x: 0, y: 0 });

            useEffect(() => { if (window.lucide) window.lucide.createIcons(); });
            useEffect(() => {
                if (gameState.score > highScore) {
                    setHighScore(gameState.score);
                    localStorage.setItem('evoHighScore', gameState.score);
                }
            }, [gameState.score, highScore]);

            // Очистка уничтоженных плиток ПОСЛЕ завершения CSS транзишена (150ms)
            useEffect(() => {
                const hasDestroyed = gameState.tiles.some(t => t.isDestroyed);
                if (hasDestroyed) {
                    const timer = setTimeout(() => {
                        setGameState(prev => ({
                            ...prev,
                            tiles: prev.tiles.filter(t => !t.isDestroyed).map(t => ({...t, isNew: false, isMerged: false}))
                        }));
                    }, 150);
                    return () => clearTimeout(timer);
                }
            }, [gameState.tiles]);

            const initAudio = () => {
                if (!audioCtx.current) audioCtx.current = new (window.AudioContext || window.webkitAudioContext)();
            };

            const playSound = (type, level = 1) => {
                if (!audioCtx.current) return;
                const ctx = audioCtx.current;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain); gain.connect(ctx.destination);
                if (type === 'move') {
                    osc.type = 'sine'; osc.frequency.setValueAtTime(120, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(40, ctx.currentTime + 0.1);
                    gain.gain.setValueAtTime(0.05, ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);
                    osc.start(); osc.stop(ctx.currentTime + 0.1);
                } else if (type === 'merge') {
                    osc.type = 'triangle'; osc.frequency.setValueAtTime(300 * Math.pow(1.15, level), ctx.currentTime);
                    gain.gain.setValueAtTime(0.15, ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);
                    osc.start(); osc.stop(ctx.currentTime + 0.2);
                }
            };
            const vibrate = (pattern) => { if (navigator.vibrate) navigator.vibrate(pattern); };

            const createTile = (r, c, val) => ({ id: tileIdCounter.current++, r, c, val, isNew: true, isMerged: false, isDestroyed: false });

            const handleRestart = useCallback(() => {
                tileIdCounter.current = 1;
                let emptyCells = [];
                for(let r=0; r<4; r++) for(let c=0; c<4; c++) emptyCells.push({r, c});
                
                const pos1 = emptyCells.splice(Math.floor(Math.random() * emptyCells.length), 1)[0];
                const pos2 = emptyCells.splice(Math.floor(Math.random() * emptyCells.length), 1)[0];
                
                setGameState({
                    tiles: [
                        createTile(pos1.r, pos1.c, Math.random() < 0.9 ? 2 : 4),
                        createTile(pos2.r, pos2.c, Math.random() < 0.9 ? 2 : 4)
                    ],
                    score: 0,
                    gameOver: false
                });
                setScoreAdds([]);
            }, []);

            // Запускаем игру при первом рендере
            useEffect(() => { handleRestart(); }, [handleRestart]);

            const move = useCallback((dir) => {
                if (gameState.gameOver || isMoving.current) return;
                initAudio();

                setGameState(prevState => {
                    let newTiles = JSON.parse(JSON.stringify(prevState.tiles));
                    // Убираем старые флаги анимаций перед новым ходом
                    newTiles.forEach(t => { t.isNew = false; t.isMerged = false; });
                    // Очищаем «убитые» тайлы, если игрок свайпнул слишком быстро
                    newTiles = newTiles.filter(t => !t.isDestroyed);

                    const getTile = (r, c) => newTiles.find(t => t.r === r && t.c === c && !t.isDestroyed);
                    
                    let hasMoved = false;
                    let addedScore = 0;
                    let maxMergeLevel = 0;

                    // Функция прохода по линии
                    const traverse = (xs, ys, dr, dc) => {
                        xs.forEach(x => {
                            ys.forEach(y => {
                                let r = (dir === 'UP' || dir === 'DOWN') ? y : x;
                                let c = (dir === 'LEFT' || dir === 'RIGHT') ? y : x;
                                
                                let tile = getTile(r, c);
                                if (!tile) return;

                                let targetR = r;
                                let targetC = c;
                                let nextTile = null;

                                // Ищем крайнюю доступную позицию или плитку для слияния
                                while (true) {
                                    let nextR = targetR + dr;
                                    let nextC = targetC + dc;
                                    if (nextR < 0 || nextR >= 4 || nextC < 0 || nextC >= 4) break;
                                    
                                    let collision = getTile(nextR, nextC);
                                    if (collision) {
                                        nextTile = collision;
                                        break;
                                    }
                                    targetR = nextR;
                                    targetC = nextC;
                                }

                                if (nextTile && nextTile.val === tile.val && !nextTile.isMerged) {
                                    // Слияние: текущая плитка едет к цели и уничтожается
                                    tile.r = nextTile.r;
                                    tile.c = nextTile.c;
                                    tile.isDestroyed = true;

                                    nextTile.val *= 2;
                                    nextTile.isMerged = true;
                                    
                                    hasMoved = true;
                                    addedScore += nextTile.val;
                                    maxMergeLevel = Math.max(maxMergeLevel, TILE_DATA[nextTile.val]?.level || 1);
                                } else if (targetR !== r || targetC !== c) {
                                    // Просто сдвиг
                                    tile.r = targetR;
                                    tile.c = targetC;
                                    hasMoved = true;
                                }
                            });
                        });
                    };

                    let arr = [0, 1, 2, 3];
                    let revArr = [3, 2, 1, 0];
                    if (dir === 'LEFT') traverse(arr, arr, 0, -1);
                    if (dir === 'RIGHT') traverse(arr, revArr, 0, 1);
                    if (dir === 'UP') traverse(arr, arr, -1, 0);
                    if (dir === 'DOWN') traverse(arr, revArr, 1, 0);

                    if (hasMoved) {
                        // Спавн новой плитки
                        let emptyCells = [];
                        for(let r=0; r<4; r++) {
                            for(let c=0; c<4; c++) {
                                if (!getTile(r, c)) emptyCells.push({r, c});
                            }
                        }
                        if (emptyCells.length > 0) {
                            const {r, c} = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                            newTiles.push(createTile(r, c, Math.random() < 0.9 ? 2 : 4));
                        }

                        // Звук и вибрация
                        if (addedScore > 0) {
                            playSound('merge', maxMergeLevel);
                            vibrate(40);
                            setScoreAdds(prev => [...prev, { id: Date.now(), val: addedScore }]);
                        } else {
                            playSound('move');
                            vibrate(15);
                        }

                        // Блокировка хода до завершения анимации (предотвращает спам кнопками)
                        isMoving.current = true;
                        setTimeout(() => { isMoving.current = false; }, 150);

                        // Проверка Game Over
                        let isOver = true;
                        if (emptyCells.length > 1) {
                            isOver = false; // Точно есть куда ходить
                        } else {
                            // Проверяем возможность слияния
                            for (let r = 0; r < 4; r++) {
                                for (let c = 0; c < 4; c++) {
                                    let val = getTile(r,c)?.val;
                                    if (!val) { isOver = false; break; }
                                    if (c < 3 && val === getTile(r, c+1)?.val) isOver = false;
                                    if (r < 3 && val === getTile(r+1, c)?.val) isOver = false;
                                }
                            }
                        }

                        return { tiles: newTiles, score: prevState.score + addedScore, gameOver: isOver };
                    }
                    return prevState;
                });
            }, [gameState.gameOver]);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) e.preventDefault();
                    switch (e.key) {
                        case 'ArrowUp': move('UP'); break;
                        case 'ArrowDown': move('DOWN'); break;
                        case 'ArrowLeft': move('LEFT'); break;
                        case 'ArrowRight': move('RIGHT'); break;
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [move]);

            const handleTouchStart = (e) => { touchStart.current = { x: e.touches[0].clientX, y: e.touches[0].clientY }; initAudio(); };
            const handleTouchEnd = (e) => {
                if (!touchStart.current) return;
                const deltaX = e.changedTouches[0].clientX - touchStart.current.x;
                const deltaY = e.changedTouches[0].clientY - touchStart.current.y;
                if (Math.max(Math.abs(deltaX), Math.abs(deltaY)) > 40) { 
                    if (Math.abs(deltaX) > Math.abs(deltaY)) { deltaX > 0 ? move('RIGHT') : move('LEFT'); } 
                    else { deltaY > 0 ? move('DOWN') : move('UP'); }
                }
            };

            // Отрисовка пустой сетки на фоне
            const renderGrid = () => {
                let grid = [];
                for(let r=0; r<4; r++) {
                    for(let c=0; c<4; c++) {
                        grid.push(<div key={`bg-${r}-${c}`} className="w-full h-full bg-gray-900/40 rounded-xl border border-white/5 shadow-inner backdrop-blur-sm"></div>);
                    }
                }
                return grid;
            };

            return (
                <div className="w-full max-w-md flex flex-col items-center relative" onTouchStart={handleTouchStart} onTouchEnd={handleTouchEnd}>
                    <div className="w-full flex justify-between items-end mb-6 px-2">
                        <div>
                            <h1 className="text-3xl font-black tracking-wider text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-500 drop-shadow-[0_2px_10px_rgba(168,85,247,0.5)]">ЭВОЛЮЦИЯ</h1>
                            <p className="text-xs text-purple-200/70 font-bold uppercase tracking-[0.2em] mt-1 ml-1">Плавная Эра</p>
                        </div>
                        <div className="flex gap-2">
                            <div className="glass-panel px-4 py-2 rounded-xl text-center relative">
                                <p className="text-[10px] text-purple-200/60 font-bold uppercase tracking-wider mb-0.5">Счет</p>
                                <p className="text-lg font-black text-white drop-shadow-lg leading-none">{gameState.score}</p>
                                {scoreAdds.map(add => <div key={add.id} className="score-anim right-0 top-0 text-sm">+{add.val}</div>)}
                            </div>
                            <div className="glass-panel px-4 py-2 rounded-xl text-center hidden sm:block">
                                <p className="text-[10px] text-purple-200/60 font-bold uppercase tracking-wider mb-0.5">Рекорд</p>
                                <p className="text-lg font-black text-white/80 drop-shadow-lg leading-none">{highScore}</p>
                            </div>
                        </div>
                    </div>

                    <div className="board-container glass-panel w-full aspect-square rounded-3xl shadow-2xl border-purple-500/20">
                        {gameState.gameOver && (
                            <div className="absolute inset-0 z-50 flex flex-col items-center justify-center rounded-3xl backdrop-blur-md bg-black/70 transition-all duration-500">
                                <h2 className="text-3xl font-black text-red-500 mb-6 drop-shadow-[0_0_20px_rgba(239,68,68,0.8)] tracking-widest uppercase text-center">Крах<br/>Цивилизации</h2>
                                <button onClick={handleRestart} className="px-8 py-4 bg-gradient-to-r from-purple-600 to-cyan-600 hover:from-purple-500 hover:to-cyan-500 text-white font-bold rounded-full transition-all shadow-[0_0_20px_rgba(168,85,247,0.5)] hover:scale-105 active:scale-95 tracking-wider uppercase text-sm">
                                    Перезапустить
                                </button>
                            </div>
                        )}
                        
                        {/* Фоновая сетка */}
                        <div className="grid grid-cols-4 gap-2 w-full h-full relative z-0">
                            {renderGrid()}
                        </div>

                        {/* Слой с активными плитками */}
                        {gameState.tiles.map(tile => {
                            const tileInfo = TILE_DATA[tile.val];
                            if (!tileInfo) return null;
                            
                            // Вычисляем Z-index: анимация слияния поверх всего, уничтожаемые плитки уходят под низ
                            let zIndex = 20;
                            if (tile.isDestroyed) zIndex = 10;
                            if (tile.isMerged) zIndex = 30;

                            return (
                                <div 
                                    key={tile.id}
                                    className={`tile-animated z-[${zIndex}]`}
                                    style={{ '--c': tile.c, '--r': tile.r, zIndex: zIndex }}
                                >
                                    <div 
                                        className={`tile-base flex flex-col items-center justify-center rounded-xl transition-all
                                            ${tile.isNew ? 'tile-new-appear' : ''} 
                                            ${tile.isMerged ? 'tile-merged-pop' : ''}
                                        `}
                                        style={{
                                            boxShadow: tileInfo.glow,
                                            background: `linear-gradient(135deg, rgba(255,255,255,0.15) 0%, rgba(0,0,0,0) 100%), rgba(30, 41, 59, 0.8)`
                                        }}
                                    >
                                        <span className={`flex items-center justify-center w-8 h-8 md:w-10 md:h-10 ${tileInfo.color}`}>
                                            <i data-lucide={tileInfo.icon} className="w-full h-full drop-shadow-md"></i>
                                        </span>

                                        {tile.isMerged && (
                                            <>
                                                <div className="particle" style={{ '--tx': '-35px', '--ty': '-35px', backgroundColor: tileInfo.color.replace('text-', '') }}></div>
                                                <div className="particle" style={{ '--tx': '35px', '--ty': '-35px', backgroundColor: tileInfo.color.replace('text-', '') }}></div>
                                                <div className="particle" style={{ '--tx': '-35px', '--ty': '35px', backgroundColor: tileInfo.color.replace('text-', '') }}></div>
                                                <div className="particle" style={{ '--tx': '35px', '--ty': '35px', backgroundColor: tileInfo.color.replace('text-', '') }}></div>
                                            </>
                                        )}
                                    </div>
                                </div>
                            );
                        })}
                    </div>

                    <div className="w-full flex justify-between gap-4 mt-8">
                        <button onClick={handleRestart} className="flex-1 py-4 glass-panel hover:bg-white/10 rounded-2xl text-xs font-bold uppercase tracking-widest transition-all hover:scale-[1.02] active:scale-[0.98] text-purple-200/80 hover:text-white border-purple-500/30">
                            Начать Заново
                        </button>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
